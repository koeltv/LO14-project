#!/bin/bash

display_usage() {
	echo "Usage: pcrontab [-u user] {-l | -r | -e}"
	exit 1
}


parse_file() {
    log_file="/var/log/pcron"
    #checking the file is existing and readable
    if [ ! -r "$1" ]; then
        echo "le fichier n'est pas lisible ou n'existe pas" 
        return 1
    else
        #define a boolean to be true if the file is correct and false otherwise
        correct=0
        #define the numbers that are alowed for each part of the schedule
        types=(
  	    '[0-3]'
  	    '[1-5]?[0-9]'
  	    '1?[0-9]$|^2[0-3]'
  	    '[1-2]?[0-9]$|^3[0-1]'
    	    '[1-9]$|^1[0-2]'
    	    '[0-6]'
	)
        line=1 #keep track of the lines
        # Check each lines, not-commented lines should be checked
        while read ligne
        do
            if ! echo "$ligne" | grep -q '^#' ; then
                field=0 #keep track of the field number
		set -f #désactive le globbing pour pouvoir lire les * comme des caractères normaux
                for mot in $ligne
                do
		    set +f
                    if [ "$field" -gt 5 ]; then 
                        break
                    fi
                    if [ "$(echo "$mot" | awk 'BEGIN {FS="-"} {print NF}')" -eq 2 ]; then
                    #checks if the field is an interval of values, and if the values entered are correct
                        first="$(echo "$mot" | cut -d"-" -f1)"
                        if [ "$(echo "$mot" | awk 'BEGIN {FS="~"} {print NF}')" -lt 2 ]; then
                            last="$(echo "$mot" | cut -d"-" -f2)"
                        else
                            last="$(echo "$mot" | cut -d"~" -f1 | cut -d"-" -f2)"
                        fi
                        if [ "$first" -ge "$last" ]; then
                            correct=1
                            echo "l'intervalle du champ $((field+1)) de la ligne $line est incorrect : la première valeur est plus grande que la seconde" 2>> "$log_file"
                            break
                        else 
                            for i in $(seq 2 "$(echo "$mot" | awk 'BEGIN {FS="~"} {print NF}')")
                            do
                                bannedValue=$(echo "$mot" | cut -d"~" -f"$i")
                                if [ "$bannedValue" -lt "$first" ] || [ "$bannedValue" -gt "$last" ]; then
                                    correct=2
                                    echo "la valeur bannie $bannedValue de l'intervalle du champ $((field+1)) de la ligne $line doit être comprise dans l'intervalle inital" 2>> "$log_file"
                                    break
                                fi
                            done
                        fi
                    fi
                    #calls the types value that fits with the field number
                    type=${types[$field]}
                    if ! echo "$mot" | grep -E -q "^$type(:$type)*$|^$type-$type(\~$type)*$|^\*\/$type$|^\*$" ; then
                        correct=3
                        echo "la valeur $mot est incorrecte sur le champ $((field+1)) de la ligne $line" 2>> "$log_file"
                    fi
                    ((field++))
                done
            fi
        ((line++))
        done < "$1"
        return $correct
    fi
}


file_usage="# Edit this file to introduce tasks to be run by pcron.
#
# Each task to run has to be defined through a single line
# indicating with different fields when the task will be run
# and what command to run for the task
#
# To define the time you can provide concrete values for
# second (s), minute (m), hour (h), day of month (dom), month (mon),
# and day of week (dow) or use '*' in these fields (for 'any').
#
# Notice that tasks will be started based on the pcron's system
# daemon's notion of time and timezones.
#
# Each action of the pcrontab jobs (including errors) are logged
# to /var/log/pcron.
#
# For example, you can run a backup of all your user accounts
# at 5 a.m every week with:
# 0 0 5 * * 1 tar -zcf /var/backups/home.tgz /home/
#
# s m h dom mon dow command
"

# Parse options
user="$USER"
while getopts ":u:lre" opt; do
    case $opt in
        u) user="$OPTARG" ;;
        l) action="list" ;;
        r) action="remove" ;;
        e) action="edit" ;;
        *) display_usage ;;
    esac
done

pcron_dir="/etc/pcron"
pcron_user_file="$pcron_dir/pcrontab${user}"

case $action in
    list)
    		if [ -r "$pcron_user_file" ]; then
    			cat "$pcron_user_file"
    		else
    			echo "no pcrontab for $user"
    		fi
    		;;
    remove) rm "$pcron_user_file" ;;
    edit)
        temp_file="/tmp/pcrontab${user}"

        if [ -r "$pcron_user_file" ]; then
        	cp "$pcron_user_file" "$temp_file"
        else
        	echo "$file_usage" > "$temp_file"
        fi

        vi "$temp_file"
        until parse_file "$temp_file" ; do
        	echo "There is an error in $temp_file, do you wish to fix it (y/n) ?"
        	read answer
        	if [ "$answer" == "n" ]; then
        		exit 1
        	elif [ "$answer" == "y" ]; then
        		vi "$temp_file"
        	fi
        done
        mkdir -p "$pcron_dir"
        cp "$temp_file" "$pcron_user_file"
        rm "$temp_file"
        ;;
    *) display_usage ;;
esac
